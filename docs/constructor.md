# 编译器默认提供的函数
1. 默认构造函数
2. 默认析构函数
3. 默认拷贝构造函数
4. 赋值运算符operator=
5. 移动构造
6. 移动赋值
```
class A{

};

```

# 拷贝构造 vs. 移动构造
```cpp
int a = std::move(b); //首先尝试移动构造，然后尝试拷贝构``
```


### 合成拷贝构造的限制
如果**类的成员拷贝构造函数是删除的或不可访问的**，则类合成的拷贝构造函数被定义为删除的。
如果**类的成员的析构函数是删除的或不可访问的**，则类合成的拷贝函数也被定义为删除的。

### 合成默认拷贝构造函数的限制
如果类的某个成员的析构函数是删除或不可访问的，
如果类有一个引用成员，没有在类内部进行初始化，
如果类有一个const成员，同样没有在类内部初始化且其类型为显示定义默认构造函数
```cpp
struct X {
};
struct Y {
  const struct X x; // error: X没有在内部初始化，并且没有显示提供默认构造函数
}
```

### 合成移动构造的限制
如果有类成员定义了自己的拷贝构造函数且未定义移动拷贝构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。
如果有类成员的移动移动函数或移动赋值运算符被定义为删除的或是不可访问的。
如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的
如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数或移动赋值运算符了。

类似于拷贝赋值运算符，如果有类成员是const的或是引用，则类的移动赋值运算符被定义为删除的。
```cpp
struct X {
  X() = default; // 为下面const成员显示提供默认构造函数
  X(const X& x) {cout << "copy constructor" << endl;}
}
struct Y {
  const struct X x;
}

Y y;
Y y1 = std::move(y); // output: copy constructor
Y y2;
y2 = std::move(y); // error: use of deleted function Y& Y::operator=(Y&&）
```

### 拷贝函数代替移动
如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作.
```cpp
struct X {
  X() = default;
  X(const X& x) {cout << "copy constructor" << endl;}
};

X x;
X x1 = std::move(x);  // ok!

//output:
// copy constructor
```


### 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符 
```cpp
class HasPtr {
public:
  HasPtr& operator=(HasPtr rhs) {
    swap(*this, rhs);
    return *this;
  }
}

hp = hp2; // hp2是一个左值；实参调用拷贝构造函数进行构造
hp = std::move(hp2); // 实参调用移动构造函数进行构造
```

### 三/五法则
一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作（拷贝构造，拷贝赋值，析构，移动构造，移动赋值）
通常情况下


